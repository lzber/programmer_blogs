# 序

复习一下页面置换算法和缓存置换算法。



#  OPT

理想 (最佳、最优)置换算法（ OPT, optimal，最优的）

设计思想：置换以后不再需要的或最远的将来才会用到的页面

仅供评价，benchmark, 永远无法实现。  



# LRU

最近最久未使用（Least Recently Used，LRU）算法。

它假设如下：现在不怎么使用的页面，以后可能也不会用到，所以可以被优先替换。理论应该是时间局部性。

LRU性能较好，但需要寄存器和栈的硬件支持，LRU是堆栈类的算法，理论上可以证明，堆栈类算法不可能出现Belady异常。

软件代码具体实现可以使用哈希链表法，具体参考 [TODO小灰]。

硬件算法有以下两个【参考】：

首先，如果硬件有一个64位的计数器，每条指令执行完后自动加1。在每个页表项里添加一个域，用于存放计数器的值。进程运行，每次访问页面的时候，都把计数器的值保存在被访问页面的页表项中。一旦发生缺页，操作系统检查页表中所有的计数器的值以找出最小的一个，那这一页就是最久未使用的页面，调出即可。

其次，另外一个矩阵算法：在一个有n个页框的机器中，LRU硬件可以维持一个n*n的矩阵，开始时所有位都是0。访问到第k页时，硬件把k行的位全设为1，之后再把k列的位置设为0。容易证明，在任意时候，二进制值最小的行即为最久未使用的页面，当调换页面时，将其调出（涉及矩阵乘法，大佬自行证明，菜鸡记住就可以了）。

以上的两种算法，无疑都要比纯粹的软件算法方便且快捷。每次页面访问之后的操作——保存计数器值和设置k行k列的值，时间复杂度都是O(1)量级，与纯软件算法不可同日而语。





# LFU

最不常用（LFU，Least Frequently Used）算法

基于如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小的思路。

这种算法选择最近时期使用次数最少的页作为淘汰页。为每个页面配置一个计数器，一旦某页被访问，则将其计数器的值加1，在需要选择一页置换时，则将选择其计数器值最小的页面，即内存中访问次数最少的页面进行淘汰。

这种算法可能存在的问题是：有些也在进程开始时被访问的次数很多，但以后这些页可能不再被访问，这样的页不该长时间停留在内存中。解决这个问题的方法之一是定期的将计时器右移，以形成指数衰减的平均使用次数。


# NRU

Not Recently Used
选择在最近一段时间内未使用过的一页并置换
实现：设置页表表项的两位
访问位（ R）， 修改位（ M）
启动一个进程时， R、 M位置0
R位被定期清零（复位）

发生缺页中断时，操作系统检查 R， M：
第0类：无访问，无修改
第1类：无访问，有修改
第2类：有访问，无修改
第3类：有访问，有修改
算法思想：
***随机***从***编号最小的非空类***中选择一页置换

（摘录自陈老师ppt）



###  基于CLOCK算法的NRU 实现

NRU的时钟算法实现

1．从指针的当前位置开始，扫描页框缓冲区，选择遇到的第一个页框（ r=0； m=0）用于置换(本扫描过程中，对访问位不做任何修改)

2．如果第1步失败，则重新扫描，选择第一个（ r=0； m=1）的页框(本次扫描过程中，对每个跳过的页框，将其访问位设置成0)，注意，如果用户设置了保存按钮等，需要将修改了的页表写回硬盘

3．如果第2步失败，指针将回到它的最初位置，并且集合中所有页框的访问位均为0。

重复第1步，并且，如果有必要，重复第2步。这样将可以找到供置换的页框

提示：与上面介绍的NRU有区别。



# NFU

最不经常使用算法(NFU)

Not Frequently Used
选择访问次数最少的页面置换
***LRU的一种软件解决方案***，并不是一种新的算法。
实现：
➢ 软件计数器，一页一个，初值为0
➢ 每次时钟中断时，计数器加R
➢ 发生缺页中断时，选择计数器值最小的一页置换



# 老化算法(AGING)

NFU改进（模拟LRU） ：计数器在加R前先右移一位, R位加到计数器的最左端。
下面参考中有详细解释。


# 其他

- FIFO 和 CLOCK 算法的异同

  其实一个是普通队列，另一个循环队列，穿了个马甲而已。
  
- 第二次机会置换算法(SCR)

  SCR-Second Chance,按照先进先出算法选择某一页面，检查其访问位R，如果为0，则置换该页；如果为1，则给第二次机会，并将访问位置0。



# 参考

- 内存管理-LRU,NFU，Aging算法实现
  https://blog.csdn.net/ryan_jianjian/article/details/53040918

- LRU算法的实现
  https://blog.csdn.net/quitepig/article/details/8045187 

- 常用缓存淘汰算法（LFU、LRU、ARC、FIFO、MRU）

  https://mp.weixin.qq.com/s?src=11&timestamp=1580915975&ver=2140&signature=cwKj6U2pZvKpiS*M1Hgf6qsq8cnTur27a50NZBTE9zACZZ87CJI9MmDgxIRxQkyHIKQ96eebu02MhMTqbWCZsyQKHr8mNJIGobRcqHxeyqyUUCoi01spZewdqyRWMcR&new=1

  
